---
layout: post
title: 虚函数
date: 2016-04-07T14:37:44.000Z
categories: update
---
一个抽象数据定义了一种黑盒子。一旦定义好之后，它就不会实际地与程序其他部分产生交互作用了。没有其他办法能为某些新的用途而调整它，除非是修改它的定义。这可能带来很严重的灵活性问题。考虑一个为在图形系统里使用而定义的shape类型。假设目前情况下系统必须支持、三角形和矩形，再假定你已经有了一些类：
class point{/*…*/};
class color{/*…*/};
你可能把shape类定义成下面的样子：
<img src="/images/fulls/屏幕快照 2016-04-07 下午3.57.39.png" class="fit image">
这里“表示种类的域”k是必须的，以便draw（）和rotate（）一类函数能确定它们当时正在处理的形状（shape）的种类。函数draw（）的定义可能像下面这样：
<img src="/images/fulls/屏幕快照 2016-04-07 下午3.57.54.png" class="fit image">
各位看到了，像draw（）这样的函数必须“理解”现存的所有形状。这样，每当有一种新形状被加入系统时，所有这类函数的代码都必须扩充。如果你定义了一个新形状，处理形状的每个操作都必须检查并（做可能需要的）修改。如果你无法接触所有这些操作的源代码，就无法将一个新的形状加入系统里。实际问题是，在这里没有区分任意形状的普遍性质（例如，一个形状有一种颜色，它可以被画出来，等等）和与某种特定形状有关的属性（例如，一个形状有一种颜色，它可以被画出来，等等）和与某种特定形状有关的属性（例如，圆是一种有圆心的形状，应该由一个画圆的函数来画，等等）。面向对象的程序设计就是要表达这种差异并从中获益。如果在某种语言里存在能够表达和利用这种差异的结构，它就能支持面向对象的程序设计。其他语言则不行。
首先 我们描述一个类，用它定义所有形状的普遍性质：
<img src="/images/fulls/屏幕快照 2016-04-07 下午4.35.56.png" class="fit image">
那些只能在这里给出调用界面定义，而又必须针对每个特定类型专门定义实现的函数，在这里都需要标明virtual。有了这个定义，我们就可以写出对各种形状进行操作的通用函数了：
<img src="/images/fulls/屏幕快照 2016-04-07 下午4.44.53.png" class="fit image">
如果要定义一个特定类型，我们必须说明它是一个形状，而后再描述那些特殊性质。
简单来说，当基类指针指向一个子类对象，通过这个指针调用子类和基类同名成员函数的时候，基类声明为虚函数，就会调子类的这个函数，不声明就会调用基类的。如果没有虚函数的话，管理一堆差不多但是类型又不一样的对象的时候就比较麻烦了。虚函数在时间和空间和常规函数同样有效，但是设置虚函数既需要代码空间，又需要执行空间，而且编译器编译器不好优化。因为编译器只知道你要调用的是一个不确定的地址处的函数，没法知道更多细节，也就没法替你做更多优化，而且使用对象+虚函数并不容易让人看清数据之间的关系。
C++规则规定虚函数必须在它们最先声明的类里定义。为了保证传统连接程序可以用于C++程序的连接，并保证不会出现没有调用虚函数的情况。带有一个或几个纯虚函数的类是一个抽象类。抽象类只能用作其他类的基类，不可能建立抽象类的对象。从一个抽象类派生的类必须是给其基类的纯虚函数提供定义，或者是重新将它们定义为纯虚函数。纯虚函数禁止对抽象类的函数以传值方式调用。 纯虚函数跟其他函数的不同之处是，其它虚函数都是把函数地址放在虚表中，调用的时候根据地址调用函数，而纯虚函数因为没有实现，虚表中第一项放的地址是_purecall这个函数，用于在非法调用的时候弹出出错信息;
